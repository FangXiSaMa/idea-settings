<application>
  <component name="AppStorage">
    <histories>
      <item value="opcode" />
      <item value="An {@link AuthorizedUrl} that allows optionally configuring the" />
      <item value="druid" />
      <item value="* Requests that the file or directory denoted by this abstract * pathname be deleted when the virtual machine terminates. * Files (or directories) are deleted in the reverse order that * they are registered. Invoking this method to delete a file or * directory that is already registered for deletion has no effect. * Deletion will be attempted only for normal termination of the * virtual machine, as defined by the Java Language Specification." />
      <item value="folder" />
      <item value="chunk" />
      <item value="Resolving eureka endpoints via configuration" />
      <item value="11" />
      <item value="文件系统" />
      <item value="implement" />
      <item value="implements" />
      <item value="sys Dictionary Repository" />
      <item value="select All" />
      <item value="继续" />
      <item value="物理路径" />
      <item value="publish" />
      <item value="发布" />
      <item value="商家" />
      <item value="运营商" />
      <item value="optional" />
      <item value="UNAUTHORIZED" />
      <item value="PAYMENT REQUIRED" />
      <item value="NOT ACCEPTABLE" />
      <item value="laster" />
      <item value="规格" />
      <item value="manager" />
      <item value="审核" />
      <item value="seller" />
      <item value="* Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task." />
      <item value="推送" />
      <item value="focus" />
      <item value="PROXY AUTHENTICATION REQUIRED" />
      <item value="REQUEST TIMEOUT" />
      <item value="LOOP DETECTED" />
      <item value="BANDWIDTH LIMIT EXCEEDED" />
      <item value="NOT EXTENDED" />
      <item value="NETWORK AUTHENTICATION REQUIRED" />
      <item value="VARIANT ALSO NEGOTIATES" />
      <item value="HTTP VERSION NOT SUPPORTED" />
      <item value="GATEWAY TIMEOUT" />
      <item value="INTERNAL SERVER ERROR" />
      <item value="REQUEST HEADER FIELDS TOO LARGE" />
      <item value="UNSUPPORTED MEDIA TYPE" />
      <item value="PRECONDITION FAILED" />
      <item value="CONFLICT" />
      <item value="PERMANENT REDIRECT" />
      <item value="METHOD NOT ALLOWED" />
      <item value="FORBIDDEN" />
      <item value="Unauthorized" />
      <item value="handle" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="103" />
        <entry key="ENGLISH" value="104" />
        <entry key="DANISH" value="2" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SPANISH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>